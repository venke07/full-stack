<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>AI Agent Flow Builder â€“ Vanilla</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #e5e7eb;
      background: #050816;
    }

    .app {
      display: flex;
      height: 100vh;
    }

    /* ----- Sidebar ----- */
    .sidebar {
      width: 260px;
      background: #020617;
      border-right: 1px solid #111827;
      padding: 1.25rem;
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .sidebar h2 {
      font-size: 1.1rem;
      margin: 0 0 0.5rem;
    }

    .palette {
      display: flex;
      flex-direction: column;
      gap: 0.5rem;
    }

    .palette-item {
      padding: 0.55rem 0.75rem;
      border-radius: 0.6rem;
      background: #020617;
      border: 1px solid #1f2937;
      font-size: 0.9rem;
      cursor: grab;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      user-select: none;
      transition: background 0.2s, border-color 0.2s, transform 0.1s;
    }

    .palette-item span.icon {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75rem;
      background: #0f172a;
    }

    .palette-item:hover {
      background: #020617;
      border-color: #3b82f6;
      transform: translateY(-1px);
    }

    .hint {
      font-size: 0.8rem;
      color: #9ca3af;
      line-height: 1.4;
    }

    /* ----- Builder area ----- */
    .builder {
      flex: 1;
      display: flex;
      flex-direction: column;
      background: radial-gradient(circle at top, #020617 0, #020617 40%, #020617 100%);
    }

    .builder-header {
      height: 56px;
      padding: 0 1.5rem;
      border-bottom: 1px solid #111827;
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(15, 23, 42, 0.97);
      backdrop-filter: blur(10px);
      position: relative;
      z-index: 2;
    }

    .builder-title {
      font-size: 1rem;
      font-weight: 500;
      color: #e5e7eb;
    }

    .toolbar {
      display: flex;
      gap: 0.5rem;
    }

    .btn {
      padding: 0.35rem 0.75rem;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      font-size: 0.8rem;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      transition: background 0.2s, border-color 0.2s, transform 0.1s;
    }

    .btn.primary {
      background: #3b82f6;
      border-color: #2563eb;
    }

    .btn:hover {
      background: #111827;
    }

    .btn.primary:hover {
      background: #2563eb;
    }

    /* ----- Canvas ----- */
    .canvas-wrapper {
      position: relative;
      flex: 1;
      overflow: hidden;
    }

    .canvas {
      position: relative;
      width: 100%;
      height: 100%;
      background-color: #020617;
      background-image: radial-gradient(circle, #111827 1px, transparent 0);
      background-size: 20px 20px;
    }

    svg.connections {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: visible;
    }

    /* ----- Nodes ----- */
    .node {
      position: absolute;
      min-width: 180px;
      max-width: 260px;
      background: #020617;
      border-radius: 0.9rem;
      border: 1px solid #1f2937;
      box-shadow: 0 14px 30px rgba(15, 23, 42, 0.8);
      padding: 0.65rem 0.75rem 0.75rem;
      cursor: grab;
      user-select: none;
      transition: box-shadow 0.2s, border-color 0.2s, transform 0.1s;
    }

    .node:hover {
      border-color: #3b82f6;
      transform: translateY(-1px);
    }

    .node-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.4rem;
    }

    .node-title {
      font-size: 0.9rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 0.35rem;
    }

    .node-pill {
      font-size: 0.65rem;
      padding: 0.1rem 0.4rem;
      border-radius: 999px;
      background: #0f172a;
      color: #9ca3af;
      border: 1px solid #111827;
    }

    .node-body {
      font-size: 0.8rem;
      color: #9ca3af;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.5rem;
    }

    .node-body small {
      opacity: 0.8;
    }

    .node-actions {
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .node-btn {
      font-size: 0.7rem;
      padding: 0.2rem 0.55rem;
      border-radius: 999px;
      border: 1px solid #1f2937;
      background: #020617;
      color: #e5e7eb;
      cursor: pointer;
      transition: background 0.2s, border-color 0.2s;
      white-space: nowrap;
    }

    .node-btn:hover {
      background: #111827;
      border-color: #3b82f6;
    }

    .node.connecting {
      border-color: #22c55e;
      box-shadow: 0 0 0 1px rgba(34, 197, 94, 0.8), 0 14px 30px rgba(15, 23, 42, 0.9);
    }

    .node-dot {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: #22c55e;
      right: -5px;
      top: 50%;
      transform: translateY(-50%);
      box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2);
    }
  </style>
</head>
<body>
<div class="app">
  <!-- Sidebar / Palette -->
  <aside class="sidebar">
    <div>
      <h2>Blocks</h2>
      <p class="hint">Drag a block into the canvas, move it around, then use <b>Connect</b> to link nodes.</p>
    </div>
    <div class="palette">
      <div class="palette-item" draggable="true" data-type="trigger">
        <span class="icon">âš¡</span> On Form Submit
      </div>
      <div class="palette-item" draggable="true" data-type="agent">
        <span class="icon">ðŸ¤–</span> AI Agent
      </div>
      <div class="palette-item" draggable="true" data-type="condition">
        <span class="icon">ðŸ§­</span> Condition
      </div>
      <div class="palette-item" draggable="true" data-type="tool">
        <span class="icon">ðŸ§©</span> Tool / API
      </div>
      <div class="palette-item" draggable="true" data-type="output">
        <span class="icon">ðŸ“¨</span> Output (Slack / Email)
      </div>
    </div>
  </aside>

  <!-- Builder -->
  <section class="builder">
    <div class="builder-header">
      <div class="builder-title">AI Agent Flow</div>
      <div class="toolbar">
        <button class="btn" id="btnExport">Export JSON</button>
        <button class="btn primary" id="btnClear">Clear</button>
      </div>
    </div>

    <div class="canvas-wrapper">
      <svg class="connections" id="connections"></svg>
      <div class="canvas" id="canvas"></div>
    </div>
  </section>
</div>

<script>
  // ==== DATA MODEL ====
  const blocks = [];        // { id, type, x, y }
  const connections = [];   // { from, to }
  let idCounter = 1;
  let connectingFrom = null;

  const canvas = document.getElementById('canvas');
  const svg = document.getElementById('connections');

  const TYPE_LABELS = {
    trigger: 'On Create User',
    agent: 'AI Agent',
    condition: 'Is Manager?',
    tool: 'Tool / Integration',
    output: 'Notify / Update'
  };

  const TYPE_DESC = {
    trigger: 'Start the workflow when an event happens.',
    agent: 'Call an AI model with tools & memory.',
    condition: 'Branch flow based on a rule.',
    tool: 'Call external APIs, DBs, or services.',
    output: 'Send messages or update systems.'
  };

  // ==== PALETTE DRAG/DROP ====
  document.querySelectorAll('.palette-item').forEach(item => {
    item.addEventListener('dragstart', e => {
      e.dataTransfer.setData('type', item.dataset.type);
    });
  });

  canvas.addEventListener('dragover', e => e.preventDefault());

  canvas.addEventListener('drop', e => {
    e.preventDefault();
    const type = e.dataTransfer.getData('type');
    if (!type) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    createNode(type, x, y);
  });

  // ==== CREATE NODE ====
  function createNode(type, x, y) {
    const id = 'node-' + idCounter++;
    const node = document.createElement('div');
    node.className = 'node';
    node.dataset.id = id;
    node.dataset.type = type;
    node.style.left = x + 'px';
    node.style.top = y + 'px';

    node.innerHTML = `
      <div class="node-header">
        <div class="node-title">
          <span>${TYPE_LABELS[type] || 'Block'}</span>
          <span class="node-pill">${type}</span>
        </div>
        <button class="node-btn node-connect">Connect</button>
      </div>
      <div class="node-body">
        <div><small>${TYPE_DESC[type] || ''}</small></div>
        <div class="node-actions">
          <button class="node-btn">Config</button>
        </div>
      </div>
      <div class="node-dot"></div>
    `;

    canvas.appendChild(node);

    blocks.push({ id, type, x, y });
    enableDragging(node);

    node.querySelector('.node-connect').addEventListener('click', (e) => {
      e.stopPropagation();
      handleConnectClick(node);
    });

    redrawConnections();
  }

  // ==== DRAGGING NODES ====
  function enableDragging(node) {
    let dragging = false;
    let offsetX = 0;
    let offsetY = 0;

    node.addEventListener('mousedown', (e) => {
      if (e.target.classList.contains('node-btn')) return;
      dragging = true;
      node.style.cursor = 'grabbing';
      const rect = node.getBoundingClientRect();
      const canvasRect = canvas.getBoundingClientRect();
      offsetX = e.clientX - rect.left;
      offsetY = e.clientY - rect.top;

      document.body.style.userSelect = 'none';
    });

    document.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const canvasRect = canvas.getBoundingClientRect();
      let x = e.clientX - canvasRect.left - offsetX;
      let y = e.clientY - canvasRect.top - offsetY;

      x = Math.max(0, Math.min(canvasRect.width - node.offsetWidth, x));
      y = Math.max(0, Math.min(canvasRect.height - node.offsetHeight, y));

      node.style.left = x + 'px';
      node.style.top = y + 'px';

      const block = blocks.find(b => b.id === node.dataset.id);
      if (block) { block.x = x; block.y = y; }

      redrawConnections();
    });

    document.addEventListener('mouseup', () => {
      if (dragging) {
        dragging = false;
        node.style.cursor = 'grab';
        document.body.style.userSelect = '';
      }
    });
  }

  // ==== CONNECTING NODES ====
  function handleConnectClick(node) {
    const id = node.dataset.id;

    if (!connectingFrom) {
      connectingFrom = id;
      node.classList.add('connecting');
      return;
    }

    if (connectingFrom === id) {
      node.classList.remove('connecting');
      connectingFrom = null;
      return;
    }

    const fromNode = canvas.querySelector(`.node[data-id="${connectingFrom}"]`);
    if (fromNode) fromNode.classList.remove('connecting');

    connections.push({ from: connectingFrom, to: id });
    connectingFrom = null;
    redrawConnections();
  }

  // ==== DRAW CONNECTIONS ====
  function redrawConnections() {
    const rect = canvas.getBoundingClientRect();
    svg.setAttribute('width', rect.width);
    svg.setAttribute('height', rect.height);
    svg.innerHTML = '';

    connections.forEach(conn => {
      const fromEl = canvas.querySelector(`.node[data-id="${conn.from}"]`);
      const toEl = canvas.querySelector(`.node[data-id="${conn.to}"]`);
      if (!fromEl || !toEl) return;

      const x1 = fromEl.offsetLeft + fromEl.offsetWidth;
      const y1 = fromEl.offsetTop + fromEl.offsetHeight / 2;
      const x2 = toEl.offsetLeft;
      const y2 = toEl.offsetTop + toEl.offsetHeight / 2;

      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      const dx = Math.max(40, (x2 - x1) / 2);
      const d = `M ${x1} ${y1} C ${x1 + dx} ${y1}, ${x2 - dx} ${y2}, ${x2} ${y2}`;

      path.setAttribute('d', d);
      path.setAttribute('stroke', '#4b5563');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('fill', 'none');
      path.setAttribute('marker-end', 'url(#arrowhead)');

      svg.appendChild(path);
    });

    // Arrow marker (once)
    if (!svg.querySelector('marker')) {
      const defs = document.createElementNS('http://www.w3.org/2000/svg', 'defs');
      const marker = document.createElementNS('http://www.w3.org/2000/svg', 'marker');
      marker.setAttribute('id', 'arrowhead');
      marker.setAttribute('markerWidth', '10');
      marker.setAttribute('markerHeight', '7');
      marker.setAttribute('refX', '10');
      marker.setAttribute('refY', '3.5');
      marker.setAttribute('orient', 'auto');

      const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      polygon.setAttribute('points', '0 0, 10 3.5, 0 7');
      polygon.setAttribute('fill', '#4b5563');

      marker.appendChild(polygon);
      defs.appendChild(marker);
      svg.appendChild(defs);
    }
  }

  // ==== EXPORT / CLEAR ====
  document.getElementById('btnExport').addEventListener('click', () => {
    const data = { blocks, connections };
    alert(JSON.stringify(data, null, 2));
  });

  document.getElementById('btnClear').addEventListener('click', () => {
    blocks.splice(0, blocks.length);
    connections.splice(0, connections.length);
    canvas.innerHTML = '';
    svg.innerHTML = '';
  });
</script>
</body>
</html>
